<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VRM Viewer with VRMA Animation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        background: #1a1a1a;
      }

      #canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-family: "Monaco", "Courier New", monospace;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-width: 400px;
        font-size: 13px;
        line-height: 1.6;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }

      #info .status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 2s ease-in-out infinite;
      }

      #info .status.connected {
        background: #00ff00;
      }

      #info .status.disconnected {
        background: #ff0000;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .title {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #00d4ff;
      }

      .line {
        margin: 5px 0;
        color: #ccc;
      }

      .line strong {
        color: #fff;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 20px;
        text-align: center;
      }

      .loading::after {
        content: "...";
        animation: dots 1.5s steps(4, end) infinite;
      }

      @keyframes dots {
        0%,
        20% {
          content: ".";
        }
        40% {
          content: "..";
        }
        60%,
        100% {
          content: "...";
        }
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="info">
      <div class="title">üé≠ VRM Viewer (VRMAÂØæÂøú)</div>
      <div class="line">
        <span class="status disconnected"></span><strong>Status:</strong>
        <span id="status-text">Connecting...</span>
      </div>
      <div class="line">
        <strong>Model:</strong> <span id="model-name">Not loaded</span>
      </div>
      <div class="line">
        <strong>Animation:</strong> <span id="animation-name">None</span>
      </div>
    </div>
    <div class="loading" id="loading">Loading Three.js</div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/+esm";
      import {
        VRM,
        VRMLoaderPlugin,
      } from "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.7/+esm";
      import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
      import {
        VRMAnimationLoaderPlugin,
        createVRMAnimationClip,
      } from "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@0.1.1/+esm";

      // „É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫„ÇíÊ∂à„Åô
      document.getElementById("loading").style.display = "none";

      // Three.jsÂàùÊúüÂåñ
      const canvas = document.getElementById("canvas");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x212121);

      const camera = new THREE.PerspectiveCamera(
        30,
        window.innerWidth / window.innerHeight,
        0.1,
        20
      );
      camera.position.set(0, 1.4, 3);
      camera.lookAt(0, 1.2, 0);

      // „É©„Ç§„Éà
      const directionalLight = new THREE.DirectionalLight(0xffffff, Math.PI);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      // VRM & „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
      let vrm = null;
      let mixer = null;
      const loadedAnimations = new Map();
      let currentAction = null;

      // VRM„É≠„Éº„ÉÄ„ÉºÔºàVRMAÂØæÂøúÔºâ
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));
      loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

      // UIÊõ¥Êñ∞Èñ¢Êï∞
      function updateStatus(text, connected = true) {
        const statusEl = document.querySelector(".status");
        const statusText = document.getElementById("status-text");
        statusEl.className = `status ${connected ? "connected" : "disconnected"}`;
        statusText.textContent = text;
      }

      function updateModelName(name) {
        document.getElementById("model-name").textContent = name;
      }

      function updateAnimationName(name) {
        document.getElementById("animation-name").textContent = name;
      }

      // WebSocketÊé•Á∂ö
      const ws = new WebSocket(`ws://${window.location.hostname}:${window.location.port}`);

      ws.onopen = () => {
        console.log("‚úì WebSocketÊé•Á∂öÊàêÂäü");
        updateStatus("Connected", true);
      };

      ws.onclose = () => {
        console.log("‚úó WebSocketÂàáÊñ≠");
        updateStatus("Disconnected", false);
      };

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        updateStatus("Error", false);
      };

      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        console.log("üì® Âèó‰ø°:", message);

        try {
          switch (message.type) {
            case "init":
              // ÂàùÊúüÂåñ„É°„ÉÉ„Çª„Éº„Ç∏
              if (message.data.isLoaded) {
                updateModelName(message.data.modelPath);
              }
              break;

            case "load_vrm_model":
              // VRM„É¢„Éá„É´Ë™≠„ÅøËæº„Åø
              updateStatus("Loading VRM...", true);
              const gltf = await loader.loadAsync(message.data.filePath);
              vrm = gltf.userData.vrm;
              
              if (!vrm) {
                throw new Error("VRM„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì");
              }

              scene.add(vrm.scene);

              // AnimationMixer„ÇíÂàùÊúüÂåñ
              mixer = new THREE.AnimationMixer(vrm.scene);

              console.log("‚úì VRM„É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü");
              updateStatus("VRM Loaded", true);
              updateModelName(message.data.filePath.split("/").pop());
              break;

            case "set_vrm_expression":
              // Ë°®ÊÉÖË®≠ÂÆö
              if (vrm?.expressionManager) {
                vrm.expressionManager.setValue(
                  message.data.expression,
                  message.data.weight
                );
                console.log(
                  `üòä Ë°®ÊÉÖË®≠ÂÆö: ${message.data.expression} = ${message.data.weight}`
                );
              }
              break;

            case "animate_vrm_bone":
              // „Éú„Éº„É≥„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
              if (vrm?.humanoid) {
                const bone = vrm.humanoid.getNormalizedBoneNode(
                  message.data.boneName
                );
                if (bone) {
                  const { x, y, z, w } = message.data.rotation;
                  bone.quaternion.set(x, y, z, w);
                  console.log(`ü¶¥ „Éú„Éº„É≥ÂõûËª¢: ${message.data.boneName}`);
                }
              }
              break;

            case "set_vrm_pose":
              // „Éù„Éº„Ç∫Ë®≠ÂÆö
              if (vrm) {
                if (message.data.position) {
                  const { x, y, z } = message.data.position;
                  vrm.scene.position.set(x, y, z);
                }
                if (message.data.rotation) {
                  const { x, y, z } = message.data.rotation;
                  vrm.scene.rotation.set(x, y, z);
                }
                console.log("üìç „Éù„Éº„Ç∫Êõ¥Êñ∞");
              }
              break;

            case "load_vrma_animation":
              // VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ë™≠„ÅøËæº„Åø
              if (!vrm) {
                console.error("VRM„É¢„Éá„É´„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì");
                break;
              }

              updateStatus("Loading VRMA...", true);
              const animGltf = await loader.loadAsync(message.data.animationPath);
              const vrmAnimations = animGltf.userData.vrmAnimations;

              if (vrmAnimations && vrmAnimations.length > 0) {
                const clip = createVRMAnimationClip(vrmAnimations[0], vrm);
                loadedAnimations.set(message.data.animationName, clip);
                console.log(
                  `‚úì VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ë™≠„ÅøËæº„Åø: ${message.data.animationName}`
                );
                updateStatus("VRMA Loaded", true);
              }
              break;

            case "play_vrma_animation":
              // VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÜçÁîü
              if (!vrm || !mixer) {
                console.error("VRM„É¢„Éá„É´„Åæ„Åü„ÅØMixer„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì");
                break;
              }

              const clip = loadedAnimations.get(message.data.animationName);
              if (!clip) {
                console.error(
                  `„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ "${message.data.animationName}" „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`
                );
                break;
              }

              // Êó¢Â≠ò„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÂÅúÊ≠¢
              if (currentAction) {
                currentAction.fadeOut(message.data.fadeInDuration || 0.3);
              }

              // Êñ∞„Åó„ÅÑ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÂÜçÁîü
              currentAction = mixer.clipAction(clip);
              currentAction.reset();
              currentAction.fadeIn(message.data.fadeInDuration || 0.3);
              currentAction.setLoop(
                message.data.loop ? THREE.LoopRepeat : THREE.LoopOnce,
                message.data.loop ? Infinity : 1
              );

              if (!message.data.loop) {
                currentAction.clampWhenFinished = true;
              }

              currentAction.play();
              console.log(
                `‚ñ∂ „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÜçÁîü: ${message.data.animationName}`
              );
              updateAnimationName(
                `${message.data.animationName} ${message.data.loop ? "(Loop)" : ""}`
              );
              break;

            case "stop_vrma_animation":
              // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢
              if (currentAction) {
                currentAction.fadeOut(message.data.fadeOutDuration || 0.3);
                setTimeout(() => {
                  if (currentAction) {
                    currentAction.stop();
                    currentAction = null;
                  }
                  updateAnimationName("None");
                  console.log("‚èπ „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢");
                }, (message.data.fadeOutDuration || 0.3) * 1000);
              }
              break;
          }
        } catch (error) {
          console.error("„Ç®„É©„Éº:", error);
          updateStatus(`Error: ${error.message}`, false);
        }
      };

      // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();

        // VRM„Ç¢„ÉÉ„Éó„Éá„Éº„Éà
        if (vrm) {
          vrm.update(deltaTime);
        }

        // AnimationMixer„Ç¢„ÉÉ„Éó„Éá„Éº„ÉàÔºàVRMAÂÜçÁîüÁî®Ôºâ
        if (mixer) {
          mixer.update(deltaTime);
        }

        renderer.render(scene, camera);
      }

      animate();

      // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÂØæÂøú
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±
      console.log("üé≠ VRM Viewer initialized");
      console.log("üì° Waiting for VRM commands...");
    </script>
  </body>
</html>

