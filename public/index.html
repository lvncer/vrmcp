<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VRM Viewer with VRMA Animation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        background: #1a1a1a;
      }

      #canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-family: "Monaco", "Courier New", monospace;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-width: 400px;
        font-size: 13px;
        line-height: 1.6;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }

      #info .status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 2s ease-in-out infinite;
      }

      #info .status.connected {
        background: #00ff00;
      }

      #info .status.disconnected {
        background: #ff0000;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .title {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #00d4ff;
      }

      .line {
        margin: 5px 0;
        color: #ccc;
      }

      .line strong {
        color: #fff;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 20px;
        text-align: center;
      }

      .loading::after {
        content: "...";
        animation: dots 1.5s steps(4, end) infinite;
      }

      @keyframes dots {
        0%,
        20% {
          content: ".";
        }
        40% {
          content: "..";
        }
        60%,
        100% {
          content: "...";
        }
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="info">
      <div class="title">üé≠ VRM Viewer (VRMAÂØæÂøú)</div>
      <div class="line">
        <span class="status disconnected"></span><strong>Status:</strong>
        <span id="status-text">Connecting...</span>
      </div>
      <div class="line">
        <strong>Model:</strong> <span id="model-name">Not loaded</span>
      </div>
      <div class="line">
        <strong>Animation:</strong> <span id="animation-name">None</span>
      </div>
    </div>
    <div class="loading" id="loading">Loading Three.js</div>

    <!-- Import Map for Three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import {
        VRM,
        VRMLoaderPlugin,
      } from "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.0.0/+esm";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      
      // ‚ö†Ô∏è VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ê©üËÉΩ„ÅØ‰∏ÄÊó¶„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„Éà
      // import {
      //   VRMAnimationLoaderPlugin,
      //   createVRMAnimationClip,
      // } from "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@1.0.7/+esm";

      // „É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫„ÇíÊ∂à„Åô
      document.getElementById("loading").style.display = "none";

      // Three.jsÂàùÊúüÂåñ
      const canvas = document.getElementById("canvas");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x212121);

      // „Éá„Éê„ÉÉ„Ç∞Áî®„Ç∞„É™„ÉÉ„Éâ
      const gridHelper = new THREE.GridHelper(10, 10);
      scene.add(gridHelper);

      // „Éá„Éê„ÉÉ„Ç∞Áî®Ëª∏„Éò„É´„Éë„Éº
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      const camera = new THREE.PerspectiveCamera(
        50, // FOV„ÇíÂ∫É„Åí„Çã
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 1.5, 5); // „ÇÇ„Å£„Å®Âºï„Åè
      camera.lookAt(0, 1, 0);

      // „É©„Ç§„ÉàÔºà„ÇÇ„Å£„Å®Êòé„Çã„ÅèÔºâ
      const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
      scene.add(ambientLight);

      // VRMÁÆ°ÁêÜ
      let vrm = null;
      let mixer = null; // Â∞ÜÊù•„ÅÆVRMAÂØæÂøúÁî®
      const loadedAnimations = new Map(); // Â∞ÜÊù•„ÅÆVRMAÂØæÂøúÁî®
      let currentAction = null; // Â∞ÜÊù•„ÅÆVRMAÂØæÂøúÁî®

      // VRM„É≠„Éº„ÉÄ„Éº
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));
      // VRMAÂØæÂøú„ÅØÂæå„ÅßËøΩÂä†
      // loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

      // UIÊõ¥Êñ∞Èñ¢Êï∞
      function updateStatus(text, connected = true) {
        const statusEl = document.querySelector(".status");
        const statusText = document.getElementById("status-text");
        statusEl.className = `status ${connected ? "connected" : "disconnected"}`;
        statusText.textContent = text;
      }

      function updateModelName(name) {
        document.getElementById("model-name").textContent = name;
      }

      function updateAnimationName(name) {
        document.getElementById("animation-name").textContent = name;
      }

      // SSEÊé•Á∂ö
      let eventSource = null;

      function connectSSE() {
        eventSource = new EventSource("/api/viewer/sse");

        eventSource.onopen = () => {
          console.log("‚úì SSEÊé•Á∂öÊàêÂäü");
          updateStatus("Connected", true);
        };

        eventSource.onerror = (error) => {
          console.error("SSE error:", error);
          updateStatus("Disconnected", false);
          
          // Ëá™ÂãïÂÜçÊé•Á∂ö (5ÁßíÂæå)
          setTimeout(() => {
            if (eventSource.readyState === EventSource.CLOSED) {
              console.log("üîÑ SSEÂÜçÊé•Á∂ö‰∏≠...");
              connectSSE();
            }
          }, 5000);
        };

        // Ê±éÁî®„É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©
        eventSource.addEventListener("message", async (event) => {
          const message = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (message):", message);
          await handleMessage(message);
        });

        // ÂêÑÁ®Æ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©
        eventSource.addEventListener("init", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (init):", data);
          if (data.isLoaded) {
            updateModelName(data.modelPath);
          }
        });

        eventSource.addEventListener("load_vrm_model", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (load_vrm_model):", data);
          await handleMessage({ type: "load_vrm_model", data });
        });

        eventSource.addEventListener("set_vrm_expression", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (set_vrm_expression):", data);
          await handleMessage({ type: "set_vrm_expression", data });
        });

        eventSource.addEventListener("animate_vrm_bone", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (animate_vrm_bone):", data);
          await handleMessage({ type: "animate_vrm_bone", data });
        });

        eventSource.addEventListener("set_vrm_pose", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (set_vrm_pose):", data);
          await handleMessage({ type: "set_vrm_pose", data });
        });

        eventSource.addEventListener("load_vrma_animation", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (load_vrma_animation):", data);
          await handleMessage({ type: "load_vrma_animation", data });
        });

        eventSource.addEventListener("play_vrma_animation", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (play_vrma_animation):", data);
          await handleMessage({ type: "play_vrma_animation", data });
        });

        eventSource.addEventListener("stop_vrma_animation", async (event) => {
          const data = JSON.parse(event.data);
          console.log("üì® Âèó‰ø° (stop_vrma_animation):", data);
          await handleMessage({ type: "stop_vrma_animation", data });
        });
      }

      // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©Èñ¢Êï∞
      async function handleMessage(message) {
        console.log("üì® Âá¶ÁêÜ:", message);

        try {
          switch (message.type) {
            case "init":
              // ÂàùÊúüÂåñ„É°„ÉÉ„Çª„Éº„Ç∏
              if (message.data.isLoaded) {
                updateModelName(message.data.modelPath);
              }
              break;

            case "load_vrm_model":
              // VRM„É¢„Éá„É´Ë™≠„ÅøËæº„Åø
              updateStatus("Loading VRM...", true);
              console.log("üîÑ VRMË™≠„ÅøËæº„ÅøÈñãÂßã:", message.data.filePath);
              
              const gltf = await loader.loadAsync(message.data.filePath);
              vrm = gltf.userData.vrm;
              
              if (!vrm) {
                throw new Error("VRM„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì");
              }

              console.log("üì¶ VRM„Éá„Éº„ÇøÂèñÂæóÊàêÂäü:", vrm);
              console.log("üìè VRM„Ç∑„Éº„É≥„ÅÆÂ≠êË¶ÅÁ¥†Êï∞:", vrm.scene.children.length);
              
              // VRM„Ç∑„Éº„É≥„ÅÆÂ¢ÉÁïå„Éú„ÉÉ„ÇØ„Çπ„ÇíË®àÁÆó
              const bbox = new THREE.Box3().setFromObject(vrm.scene);
              const size = bbox.getSize(new THREE.Vector3());
              const center = bbox.getCenter(new THREE.Vector3());
              
              console.log("üìê VRM„Çµ„Ç§„Ç∫:", size);
              console.log("üìç VRM‰∏≠ÂøÉ:", center);
              console.log("üéØ VRM‰ΩçÁΩÆ:", vrm.scene.position);
              
              scene.add(vrm.scene);
              console.log("‚úÖ „Ç∑„Éº„É≥„Å´ËøΩÂä†ÂÆå‰∫Ü");

              // AnimationMixer„ÇíÂàùÊúüÂåñ
              mixer = new THREE.AnimationMixer(vrm.scene);

              console.log("‚úì VRM„É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü");
              updateStatus("VRM Loaded", true);
              updateModelName(message.data.filePath.split("/").pop());
              break;

            case "set_vrm_expression":
              // Ë°®ÊÉÖË®≠ÂÆö
              if (vrm?.expressionManager) {
                vrm.expressionManager.setValue(
                  message.data.expression,
                  message.data.weight
                );
                console.log(
                  `üòä Ë°®ÊÉÖË®≠ÂÆö: ${message.data.expression} = ${message.data.weight}`
                );
              }
              break;

            case "animate_vrm_bone":
              // „Éú„Éº„É≥„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
              if (vrm?.humanoid) {
                const bone = vrm.humanoid.getNormalizedBoneNode(
                  message.data.boneName
                );
                if (bone) {
                  const { x, y, z, w } = message.data.rotation;
                  bone.quaternion.set(x, y, z, w);
                  console.log(`ü¶¥ „Éú„Éº„É≥ÂõûËª¢: ${message.data.boneName}`);
                }
              }
              break;

            case "set_vrm_pose":
              // „Éù„Éº„Ç∫Ë®≠ÂÆö
              if (vrm) {
                if (message.data.position) {
                  const { x, y, z } = message.data.position;
                  vrm.scene.position.set(x, y, z);
                }
                if (message.data.rotation) {
                  const { x, y, z } = message.data.rotation;
                  vrm.scene.rotation.set(x, y, z);
                }
                console.log("üìç „Éù„Éº„Ç∫Êõ¥Êñ∞");
              }
              break;

            case "load_vrma_animation":
            case "play_vrma_animation":
            case "stop_vrma_animation":
              // ‚ö†Ô∏è VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ê©üËÉΩ„ÅØ‰∏ÄÊó¶ÁÑ°ÂäπÂåñ
              // TODO: Ê≠£„Åó„ÅÑCDN„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅåË¶ã„Å§„Åã„Å£„Åü„ÇâÊúâÂäπÂåñ
              console.log(`‚ö†Ô∏è VRMAÊ©üËÉΩ„ÅØÁèæÂú®ÁÑ°Âäπ„Åß„Åô: ${message.type}`);
              updateStatus("VRMAÊ©üËÉΩ„ÅØÊú™ÂÆüË£Ö", true);
              break;
          }
        } catch (error) {
          console.error("„Ç®„É©„Éº:", error);
          updateStatus(`Error: ${error.message}`, false);
        }
      }

      // SSEÊé•Á∂ö„ÇíÈñãÂßã
      connectSSE();

      // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();

        // VRM„Ç¢„ÉÉ„Éó„Éá„Éº„Éà
        if (vrm) {
          vrm.update(deltaTime);
        }

        // AnimationMixer„Ç¢„ÉÉ„Éó„Éá„Éº„ÉàÔºàVRMAÂÜçÁîüÁî®Ôºâ
        if (mixer) {
          mixer.update(deltaTime);
        }

        renderer.render(scene, camera);
      }

      animate();

      // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÂØæÂøú
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±
      console.log("üé≠ VRM Viewer initialized");
      console.log("üì° Waiting for VRM commands...");
    </script>
  </body>
</html>

